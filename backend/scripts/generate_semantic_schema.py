import os
import yaml
from sqlalchemy import create_engine, inspect, text
from dotenv import load_dotenv
from collections import defaultdict

# --- Load environment ---
env_path = os.path.join(os.path.dirname(__file__), "..", ".env")
load_dotenv(dotenv_path=env_path)

NEON_DB_URI = os.getenv("NEON_DB_URI")
if not NEON_DB_URI:
    raise RuntimeError("‚ùå NEON_DB_URI not loaded from .env")

print(f"‚úÖ Connected using: {NEON_DB_URI[:60]}...")

engine = create_engine(NEON_DB_URI)
insp = inspect(engine)

schema_dict = {
    "summary": "Autogenerated semantic schema from live NeonDB (includes FKs).",
    "tables": [],
    "relationships": []
}

# --- Gather tables and columns ---
for table_name in insp.get_table_names():
    cols = insp.get_columns(table_name)
    pks = insp.get_pk_constraint(table_name).get("constrained_columns", [])
    table_entry = {
        "name": table_name,
        "description": f"Table '{table_name}' as found in NeonDB.",
        "primary_key": pks or None,
        "columns": [
            {
                "name": c["name"],
                "type": str(c["type"]),
                "description": f"Column '{c['name']}' of type {c['type']}"
            }
            for c in cols
        ],
    }
    schema_dict["tables"].append(table_entry)

# --- Detect Foreign Keys using information_schema ---
with engine.connect() as conn:
    fk_query = text("""
        SELECT
            tc.table_name AS from_table,
            kcu.column_name AS from_column,
            ccu.table_name AS to_table,
            ccu.column_name AS to_column,
            tc.constraint_name
        FROM information_schema.table_constraints AS tc
        JOIN information_schema.key_column_usage AS kcu
            ON tc.constraint_name = kcu.constraint_name
        JOIN information_schema.constraint_column_usage AS ccu
            ON ccu.constraint_name = tc.constraint_name
        WHERE constraint_type = 'FOREIGN KEY'
        ORDER BY from_table, to_table;
    """)
    fks = conn.execute(fk_query).fetchall()

for fk in fks:
    schema_dict["relationships"].append({
        "from_table": fk.from_table,
        "from_column": fk.from_column,
        "to_table": fk.to_table,
        "to_column": fk.to_column,
        "cardinality": "many-to-one",
        "description": f"FK {fk.constraint_name}: {fk.from_table}.{fk.from_column} ‚Üí {fk.to_table}.{fk.to_column}"
    })

print(f"üîó Found {len(fks)} foreign key relationships.")

# --- Infer logical relationships (optional heuristic for non-FK links) ---
# Example: match by hcpcs_code even if no FK
table_cols = defaultdict(set)
for t in schema_dict["tables"]:
    for c in t["columns"]:
        table_cols[t["name"]].add(c["name"].lower())

for from_table, cols in table_cols.items():
    for to_table, to_cols in table_cols.items():
        if from_table != to_table:
            common = cols.intersection(to_cols)
            for col in common:
                if col == "hcpcs_code" and not any(
                    (r["from_table"] == from_table and r["to_table"] == to_table)
                    for r in schema_dict["relationships"]
                ):
                    schema_dict["relationships"].append({
                        "from_table": from_table,
                        "from_column": col,
                        "to_table": to_table,
                        "to_column": col,
                        "cardinality": "logical",
                        "description": f"Implied relationship on shared column {col} between {from_table} and {to_table}."
                    })

# --- Write YAML ---
out_path = os.path.join(os.path.dirname(__file__), "..", "semantic_schema.yaml")
with open(out_path, "w") as f:
    yaml.dump(schema_dict, f, sort_keys=False, width=100)

print(f"‚úÖ semantic_schema.yaml regenerated with {len(schema_dict['tables'])} tables and {len(schema_dict['relationships'])} relationships.")